**เป้าหมาย**
* สร้างไดรเวอร์ที่ใช้ในการสื่อสารแบบอนุกรมระหว่างคอมพิวเตอร์และอุปกรณ์
* แก้ปัญหาข้อมูลชนกันในระหว่างการรับและส่ง
* ทำให้การรับส่งข้อมูลมีความน่าเชื่อถือและถูกต้อง

**ข้อมูลนำเข้า**
* ข้อมูลในรูปแบบไบต์อาร์เรย์ที่มีขนาดไม่คงที่
* ส่งผ่านการสื่อสารแบบอนุกรม

**ผลลัพธ์ที่ต้องการ**
* การรับข้อมูลจากอุปกรณ์ได้อย่างถูกต้องและครบถ้วน (10 Hz)
* การส่งคำสั่งไปยังอุปกรณ์ได้เมื่อต้องการ โดยไม่ชนกับการรับข้อมูล
* การได้รับข้อความตอบรับจากอุปกรณ์เมื่อส่งคำสั่ง

**กฎการทำงานของระบบ**
* อุปกรณ์ส่งข้อมูลหาคอมพิวเตอร์ที่ความเร็ว 10 Hz (ทุก 100 มิลลิวินาที)
* คอมพิวเตอร์สามารถส่งข้อมูลหาอุปกรณ์ได้ทุกเมื่อ และอุปกรณ์ต้องตอบรับเมื่อได้รับข้อมูล
* ถ้าคอมพิวเตอร์ไม่ได้รับข้อความตอบรับ ต้องทำการส่งซ้ำตามจำนวนครั้งที่กำหนด
* การรับส่งข้อมูลต้องไม่สูญหาย และข้อมูลต้องถูกต้องทุกครั้ง

**การเปรียบเทียบสองวิธีที่นำเสนอ**

| คุณสมบัติ | วิธี CSMA + Asyncio | วิธี TDD Slot |
|-------------------|-----------------------|-----------------|
| หลักการพื้นฐาน | "ฟังก่อนส่ง" - ตรวจสอบว่าช่องทางว่างไหมก่อนส่ง | แบ่งช่วงเวลาชัดเจนสำหรับอุปกรณ์และคอมพิวเตอร์ |
| การจัดการพร้อมกัน | ใช้ asyncio รองรับการทำงานหลายอย่างพร้อมกัน | ใช้ threading แบ่งการทำงานเป็นส่วนๆ |
| ข้อดี | ยืดหยุ่นกว่า รองรับการสื่อสารไม่แน่นอนได้ดี | มีโอกาสชนกันน้อยมาก เพราะแบ่งเวลาชัดเจน |
| ข้อเสีย | อาจมีการชนกันบ้างในสภาพแวดล้อมที่มีการรับส่งข้อมูลหนาแน่น | มีความล่าช้า (latency) เพิ่มขึ้นเพราะต้องรอถึงช่วงเวลาที่กำหนด |
| เหมาะกับ | ระบบที่มีการรับส่งข้อมูลไม่สม่ำเสมอ | ระบบที่ต้องการความแน่นอนในการส่งข้อมูล |

**วิธีที่ 1 : CSMA + Asyncio**
CSMA ย่อมาจาก Carrier Sense Multiple Access เป็นเทคนิคที่ใช้ในระบบที่มีหลายอุปกรณ์ใช้ช่องสื่อสารเดียวกัน เช่น สายสัญญาณ หรือคลื่นวิทยุ โดยมีหลักการพื้นฐานคือ "ฟังก่อนส่ง" โดยอุปกรณ์ต้องตรวจสอบว่าช่องสื่อสารว่างอยู่หรือไม่ก่อนจะส่งข้อมูล ถ้าไม่ว่างก็จะรอจนกว่าจะว่าง

ในโค้ดตัวอย่าง การตรวจสอบทำโดยใช้ `self.transport._serial.in_waiting > 0` เพื่อดูว่ามีข้อมูลอยู่ในบัฟเฟอร์ขาเข้าก่อนจะส่งข้อมูลออกไป ซึ่งช่วยลดการชนกันของข้อมูล

`asyncio` เป็นไลบรารีใน Python ที่ช่วยให้เขียนโค้ดแบบ Asynchronous (ไม่บล็อก) ได้ ทำให้สามารถทำหลายงานพร้อมกันโดยไม่ต้องรอให้งานหนึ่งเสร็จก่อน เช่น รับข้อมูลไปพร้อมกับส่งข้อมูล โดยไม่ทำให้โปรแกรมติดขัด

ข้อดีของ CSMA คือความยืดหยุ่นและประสิทธิภาพในสภาพแวดล้อมที่มีการรับส่งข้อมูลไม่สม่ำเสมอ ใช้ทรัพยากรรองสารได้ดี แต่อาจมีการชนกันบ้างหากอุปกรณ์หลายตัวพยายามส่งพร้อมกันพอดี

**วิธีที่ 2 : Time Division Duplexing (TDD Slot)**
วิธีนี้ใช้หลักการแบ่งช่วงเวลาให้แต่ละอุปกรณ์อย่างชัดเจน เพื่อหลีกเลี่ยงการชนกันของข้อมูลโดยสิ้นเชิง
โดยในตัวอย่างจะแบ่งเป็น:
* 80ms สำหรับอุปกรณ์ส่งข้อมูล (เทียบกับความต้องการ 10Hz หรือทุก 100ms)
* 20ms สำหรับคอมพิวเตอร์ส่งคำสั่ง

การแบ่งเวลาแบบนี้ทำให้มั่นใจได้ว่าการส่งข้อมูลจะไม่ชนกันเลย เพราะแต่ละฝ่ายมีช่วงเวลาของตัวเอง แต่ข้อเสียคือ คอมพิวเตอร์จะส่งคำสั่งได้เฉพาะในช่วง 20ms ที่กำหนดเท่านั้น ถ้าต้องการส่งนอกช่วงเวลานี้ก็ต้องรอจนกว่าจะถึงรอบถัดไป ทำให้มีความล่าช้า (latency) เพิ่มขึ้น

**การทำงานของระบบ TDD**
1. อุปกรณ์ Edge (Receiver)
* อุปกรณ์ Edge จะส่งข้อมูลทุก 100ms แต่จะมีเวลา 80ms ในการส่ง
* เมื่อถึงเวลา 20ms ที่เหลือ PC จะมีสิทธิ์ส่งคำขอ (Request)
* ถ้า PC ส่ง Request ก่อน 20ms หมด จะได้รับข้อมูลจากอุปกรณ์ Edge

2. เครื่อง PC (Requester)
* เครื่อง PC จะคอย "ถาม" ข้อมูลจาก Edge ทุก ๆ 20ms (Time Slot ของตัวเอง)
* หากเครื่อง PC ต้องการส่งคำขอกลับ อุปกรณ์ Edge จะรอจนกว่าจะถึงช่วงเวลาที่เครื่อง PC ส่งได้

TDD เหมาะกับระบบที่ต้องการความแน่นอนสูง และไม่มีปัญหากับการมีความล่าช้าระดับหนึ่ง

**คำแนะนำในการเลือกวิธี**
1. หากระบบของคุณต้องการความยืดหยุ่น และการตอบสนองที่รวดเร็ว ควรเลือกวิธี CSMA + Asyncio
2. หากระบบของคุณต้องการความแน่นอนสูงมาก ไม่ยอมให้มีการชนกันของข้อมูลเลย และสามารถยอมรับความล่าช้าได้บ้าง ควรเลือกวิธี TDD
3. ในทั้งสองวิธี มีการใช้ checksum เพื่อตรวจสอบความถูกต้องของข้อมูล ซึ่งช่วยให้มั่นใจได้ว่าข้อมูลที่รับมาถูกต้องและครบถ้วน 